///                            ____                   ______            __          __
///                           / __ `____  ___  ____  / ____/_  ______  / /_  ____  / /
///                          / / / / __ `/ _ `/ __ `/ /   / / / / __ `/ __ `/ __ `/ /
///                         / /_/ / /_/ /  __/ / / / /___/ /_/ / /_/ / / / / /_/ / /
///                         `____/ .___/`___/_/ /_/`____/`__, / .___/_/ /_/`__,_/_/
///                             /_/                     /____/_/
///
/// LibUDPard is a compact implementation of the Cyphal/UDP protocol for high-integrity real-time embedded systems.
/// It is designed for use in robust deterministic embedded systems equipped with at least 64K ROM and RAM.
/// The codebase is compliant with a large subset of MISRA C, has full test coverage, and is validated by at least
/// two static analyzers. The library is designed to be compatible with any conventional target platform and
/// instruction set architecture, from 8 to 64 bit, little- and big-endian, RTOS-based or baremetal,
/// as long as there is a standards-compliant ISO C99 compiler available.
///
/// The library offers a very low-level API that may be cumbersome to use in many applications.
/// Users seeking a higher-level API are encouraged to use LibCyphal instead, which builds on top of LibUDPard et al.
///
///
///          INTEGRATION
///
/// The library is intended to be integrated into the end application by simply copying its source files into the
/// source tree of the project; it does not require any special compilation options and should work out of the box.
/// There are build-time configuration parameters defined near the top of udpard.c, but they are optional to use.
///
/// As explained in this documentation, the library requires a deterministic constant-time dynamic memory allocator.
/// If your target platform does not provide a deterministic memory manager, it is recommended to use O1Heap
/// (MIT licensed): https://github.com/pavel-kirienko/o1heap.
///
/// To use the library, the application needs to provide an implementation of the UDP/IP stack with IGMP support.
/// POSIX-based systems may use the standard Berkeley sockets API, while more constrained embedded systems may choose
/// to rely either on a third-party solution like LwIP or a custom UDP/IP stack implementation.
///
/// Cyphal/UDP leverages only multicast IP addresses; the underlying UDP/IP stack does not need to support ARP or ICMP.
///
///
///         ARCHITECTURE
///
/// In the following description, the terms "local Cyphal node" and "application" are used interchangeably.
/// Some applications may require more than one logical Cyphal node to operate side-by-side.
/// Each logical node may utilize more than one network interface for redundancy.
///
/// This library implements the Cyphal/UDP transport protocol. Resembling the conventional OSI model, the Cyphal
/// protocol stack --- when implemented with the help of this library --- consists of the following layers:
///
///     LAYER           | DESCRIPTION
///     ----------------|---------------------------------------------------------------------------------------
///     APPLICATION     | User-defined and Cyphal-standard application logic
///     PRESENTATION    | Autogenerated code for DSDL serialization/deserialization (see Nunavut)
/// +-> TRANSPORT       | THIS LIBRARY
/// |   NETWORK         | The UDP/IP stack provided by the application (LwIP, custom, Berkeley sockets, etc).
/// |
/// +------ you are here
///
/// The library consists of three independent parts:
///
///     - The transmission pipeline (TX pipeline) for publishing messages and sending RPC-service requests & responses.
///     - The reception pipeline (RX pipeline), which in turn is built from two sub-pipelines:
///         - subscriptions -- for subscribing to subjects (aka topics);
///         - service dispatcher -- for receiving service requests and responses; both clients and servers need this.
///
/// As these components share no resources within the library, they can be used in different threads,
/// provided that there are no thread-unsafe resources shared between them in the application (such as heaps).
///
/// The library supports at most UDPARD_NETWORK_INTERFACE_COUNT_MAX redundant network interfaces.
/// Transfers received from each interface are reassembled independently and the first interface to complete a
/// transfer is always chosen to deliver the transfer to the application, while the transfers from the slower
/// interface are discarded as duplicates. The application must assign each of the redundant interface a
/// unique integer ID in the range [0, UDPARD_NETWORK_INTERFACE_COUNT_MAX) to allow the library to distinguish
/// between them.
///
/// As will be shown below, a typical application with R redundant network interfaces and S topic subscriptions needs
/// R*(S+2) sockets (or equivalent abstractions provided by the underlying UDP/IP stack).
///
/// As a matter of convention, resource disposal functions are named "free" if the memory of the resource itself is
/// not deallocated, and "destroy" if the memory is deallocated.
///
///
///     Transmission pipeline
///
/// The transmission pipeline is used to publish messages and send RPC-service requests and responses to the network
/// through a particular redundant interface. A Cyphal node with R redundant network interfaces needs to instantiate
/// R transmission pipelines, one per interface, unless the application is not interested in sending data at all.
/// The transmission pipeline contains a prioritized queue of UDP datagrams scheduled for transmission via its
/// network interface. The typical usage pattern is to enqueue Cyphal transfers using dedicated functions (see
/// udpardTxPublish, udpardTxRequest, udpardTxRespond) into all instances of transmission pipelines
/// (i.e., once per redundant interface) and periodically check the network interface for readiness to accept writes;
/// once the interface is ready, pop the next datagram scheduled for transmission from the queue and send it.
///
/// Each transmission pipeline instance requires one socket (or a similar abstraction provided by the underlying
/// UDP/IP stack) that is not connected to any specific remote endpoint (i.e., usable with sendto(),
/// speaking in terms of Berkeley sockets). In the case of redundant interfaces, each socket may need to be configured
/// to emit data through its specific interface.
///
/// Graphically, the transmission pipeline is arranged as follows:
///
///                             +---> TX PIPELINE ---> UDP SOCKET ---> REDUNDANT INTERFACE A
///                             |
///     SERIALIZED TRANSFERS ---+---> TX PIPELINE ---> UDP SOCKET ---> REDUNDANT INTERFACE B
///                             |
///                             +---> ...
///
/// The library supports configurable DSCP marking of the outgoing UDP datagrams as a function of Cyphal transfer
/// priority level. This is configured separately per TX pipeline instance (i.e., per network interface).
///
/// The maximum transmission unit (MTU) can also be configured separately per TX pipeline instance.
/// Applications that are interested in maximizing their wire compatibility should not change the default MTU setting.
///
///
///     Reception pipeline
///
/// The reception pipelines are used to subscribe to subjects (aka topics) and to receive RPC-service requests and
/// responses. The former are handled by "subscriptions" and the latter two are managed by a "service dispatcher".
/// Said pipelines are entirely independent from each other and can be operated from different threads,
/// as they share no resources.
///
/// The reception pipeline is able to accept datagrams with arbitrary MTU.
///
/// The application should instantiate one subscription instance per subject it needs to receive messages from,
/// irrespective of the number of redundant interfaces. There needs to be one socket (or a similar abstraction
/// provided by the underlying UDP/IP stack) per subscription instance per redundant interface,
/// each socket bound to the same UDP/IP endpoint (IP address and UDP port) which is selected by the library when
/// the subscription is created.
/// The application needs to listen to all these sockets simultaneously and pass the received UDP datagrams to the
/// corresponding subscription instance as they arrive, thus unifying the datagrams received from all redundant
/// interface sockets into a single stream.
/// At the output, subscription instances provide reassembled and deduplicated stream of Cyphal transfers ready for
/// deserialization.
///
/// Graphically, the subscription pipeline is arranged as shown below.
/// Remember that the application with S topic subscriptions would have S such pipelines, one per subscription.
///
///     REDUNDANT INTERFACE A ---> UDP SOCKET ---+
///                                              |
///     REDUNDANT INTERFACE B ---> UDP SOCKET ---+---> SUBSCRIPTION ---> SERIALIZED TRANSFERS
///                                              |
///                                       ... ---+
///
/// The application should instantiate a single service dispatcher instance irrespective of the number of redundant
/// interfaces or the set of RPC-services it is interested in (unless it is not interested in RPC-services at all).
/// The service dispatcher instance requires a single socket (or a similar abstraction provided by the underlying
/// UDP/IP stack) per redundant interface, each socket bound to the same UDP/IP endpoint (IP address and UDP port)
/// which is selected by the library when the service dispatcher is created.
/// The application needs to listen to all these sockets simultaneously and pass the received UDP datagrams to
/// the service dispatcher instance as they arrive, thus unifying the datagrams received from all redundant
/// interface sockets into a single stream.
///
/// The service dispatcher by itself is not useful; it needs to be configured with the set of RPC-services
/// that the application is interested in. This is done by creating RPC-service RX ports and registering them
/// with the service dispatcher. The service dispatcher will then forward the received requests and responses
/// to the corresponding RPC-service RX ports; the application can then deserialize and process them.
///
/// Graphically, the service dispatcher pipeline is arranged as shown below.
///
///   REDUNDANT INTERFACE A ---> UDP SOCKET ---+                           +---> RPC-SERVICE X ---> SERIALIZED TRANSFERS
///                                            |                           |
///   REDUNDANT INTERFACE B ---> UDP SOCKET ---+---> SERVICE DISPATCHER ---+---> RPC-SERVICE Y ---> SERIALIZED TRANSFERS
///                                            |                           |
///                                     ... ---+                           +---> ...
///
/// In summary, to make a service request, the application needs a TX pipeline to transmit the request and
/// a service dispatcher with a registered RPC-service RX port to receive the response. Same holds if the
/// application needs to handle a service request, except that the RX port will be used to accept the request
/// and the TX pipeline will be used to transmit the response.
///
///
///     Memory management
///
/// The library can be used either with a regular heap (preferably constant-time) or with a collection of fixed-size
/// block pool allocators (in safety-certified systems). It is up to the application to choose the desired memory
/// management strategy; the library is interfaced with the memory managers via a special memory resource abstraction.
///
/// Typically, if block pool allocators are used, the following block sizes should be served:
///
///     - (MTU+library overhead) blocks for the TX and RX pipelines (usually less than 2048 bytes);
///     - RX session object sized blocks for the RX pipeline (less than 512 bytes);
///     - RX fragment handle sized blocks for the RX pipeline (less than 128 bytes).
///
/// The detailed information is given in the API documentation.
///
/// --------------------------------------------------------------------------------------------------------------------
///
/// This software is distributed under the terms of the MIT License.
/// Copyright (C) OpenCyphal Development Team  <opencyphal.org>
/// Copyright Amazon.com Inc. or its affiliates.
/// SPDX-License-Identifier: MIT
/// Author: Pavel Kirienko <pavel@opencyphal.org>

#ifndef UDPARD_H_INCLUDED
#define UDPARD_H_INCLUDED

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

/// Semantic version of this library (not the Cyphal specification).
/// API will be backward compatible within the same major version.
#define UDPARD_VERSION_MAJOR 1
#define UDPARD_VERSION_MINOR 0

/// The version number of the Cyphal specification implemented by this library.
#define UDPARD_CYPHAL_SPECIFICATION_VERSION_MAJOR 1
#define UDPARD_CYPHAL_SPECIFICATION_VERSION_MINOR 0

/// These error codes may be returned from the library API calls whose return type is a signed integer in the negated
/// form (e.g., error code 2 returned as -2). A non-negative return value represents success.
/// API calls whose return type is not a signed integer cannot fail by contract.
/// No other error states may occur in the library.
/// By contract, a well-characterized application with properly sized memory pools will never encounter errors.
/// The error code 1 is not used because -1 is often used as a generic error code in 3rd-party code.
#define UDPARD_ERROR_ARGUMENT 2
#define UDPARD_ERROR_MEMORY 3
#define UDPARD_ERROR_CAPACITY 4
#define UDPARD_ERROR_ANONYMOUS 5

/// RFC 791 states that hosts must be prepared to accept datagrams of up to 576 octets and it is expected that this
/// library will receive non IP-fragmented datagrams thus the minimum MTU should be larger than 576.
/// That being said, the MTU here is set to 1408 which is derived as:
///     1500B Ethernet MTU (RFC 894) - 60B IPv4 max header - 8B UDP Header - 24B Cyphal header
#define UDPARD_MTU_DEFAULT 1408U
/// To guarantee a single frame transfer, the maximum payload size shall be 4 bytes less to accommodate for the CRC.
#define UDPARD_MTU_DEFAULT_MAX_SINGLE_FRAME (UDPARD_MTU_DEFAULT - 4U)

/// Parameter ranges are inclusive; the lower bound is zero for all. See Cyphal/UDP Specification for background.
#define UDPARD_SUBJECT_ID_MAX 8191U
#define UDPARD_SERVICE_ID_MAX 511U
#define UDPARD_NODE_ID_MAX 0xFFFEU  /// 2**16-1 is reserved for the anonymous/broadcast ID.
#define UDPARD_PRIORITY_MAX 7U

/// This value represents an undefined node-ID: broadcast destination or anonymous source.
#define UDPARD_NODE_ID_UNSET 0xFFFFU

/// This is the recommended transfer-ID timeout value given in the Cyphal Specification. The application may choose
/// different values per subscription (i.e., per data specifier) depending on its timing requirements.
#define UDPARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC 2000000UL

/// The library supports at most this many redundant network interfaces per Cyphal node.
#define UDPARD_NETWORK_INTERFACE_COUNT_MAX 3U

typedef uint64_t UdpardMicrosecond;  ///< UINT64_MAX is not a valid timestamp value.
typedef uint16_t UdpardPortID;
typedef uint16_t UdpardNodeID;
typedef uint64_t UdpardTransferID;  ///< UINT64_MAX is not a valid transfer-ID value.

/// Transfer priority level mnemonics per the recommendations given in the Cyphal Specification.
/// For outgoing transfers they are mapped to DSCP values as configured per redundant interface (per UdpardTx instance).
enum UdpardPriority
{
    UdpardPriorityExceptional = 0,
    UdpardPriorityImmediate   = 1,
    UdpardPriorityFast        = 2,
    UdpardPriorityHigh        = 3,
    UdpardPriorityNominal     = 4,  ///< Nominal priority level should be the default.
    UdpardPriorityLow         = 5,
    UdpardPrioritySlow        = 6,
    UdpardPriorityOptional    = 7,
};

/// The AVL tree node structure is exposed here to avoid pointer casting/arithmetics inside the library.
/// The user code is not expected to interact with this type except if advanced introspection is required.
struct UdpardTreeNode
{
    struct UdpardTreeNode* up;     ///< Do not access this field.
    struct UdpardTreeNode* lr[2];  ///< Left and right children of this node may be accessed for tree traversal.
    int_fast8_t            bf;     ///< Do not access this field.
};

struct UdpardMutablePayload
{
    size_t size;
    void*  data;
};

struct UdpardPayload
{
    size_t      size;
    const void* data;
};

/// This type represents payload as an ordered sequence of its fragments to eliminate data copying.
/// To free a fragmented payload buffer, the application needs to traverse the list and free each fragment's payload
/// as well as the payload structure itself, assuming that it is also heap-allocated.
/// The model is as follows:
///
///     (payload header) ---> UdpardFragment:
///                               next   ---> UdpardFragment...
///                               origin ---> (the free()able payload data buffer)
///                               view   ---> (somewhere inside the payload data buffer)
///
/// Payloads of received transfers are represented using this type, where each fragment corresponds to a frame.
/// The application can either consume them directly or to copy the data into a contiguous buffer beforehand
/// at the expense of extra time and memory utilization.
struct UdpardFragment
{
    /// Points to the next fragment in the fragmented buffer; NULL if this is the last fragment.
    struct UdpardFragment* next;

    /// Contains the actual data to be used by the application.
    /// The memory pointed to by this fragment shall not be freed by the application.
    struct UdpardPayload view;

    /// This entity points to the base buffer that contains this fragment.
    /// The application can use this pointer to free the outer buffer after the payload has been consumed.
    /// In the most simple case this field is identical to the "view" field above, but it is not always the case.
    struct UdpardMutablePayload origin;
};

/// Cyphal/UDP uses only multicast traffic.
/// Unicast support is not required; one consequence is that ARP tables are not needed.
struct UdpardUDPIPEndpoint
{
    uint32_t ip_address;
    uint16_t udp_port;
};

// =====================================================================================================================
// =================================================  MEMORY RESOURCE  =================================================
// =====================================================================================================================

/// A pointer to the memory allocation function. The semantics are similar to malloc():
///     - The returned pointer shall point to an uninitialized block of memory that is at least "size" bytes large.
///     - If there is not enough memory, the returned pointer shall be NULL.
///     - The memory shall be aligned at least at max_align_t.
///     - The execution time should be constant (O(1)).
///     - The worst-case memory consumption (worst fragmentation) should be understood by the developer.
///
/// If the standard dynamic memory manager of the target platform does not satisfy the above requirements,
/// consider using O1Heap: https://github.com/pavel-kirienko/o1heap. Alternatively, some applications may prefer to
/// use a set of fixed-size block pool allocators (see the high-level overview for details).
///
/// The API documentation is written on the assumption that the memory management functions have constant
/// complexity and are non-blocking.
///
/// The value of the user reference is taken from the corresponding field of the memory resource structure.
typedef void* (*UdpardMemoryAllocate)(void* const user_reference, const size_t size);

/// The counterpart of the above -- this function is invoked to return previously allocated memory to the allocator.
/// The size argument contains the amount of memory that was originally requested via the allocation function;
/// its value is undefined if the pointer is NULL.
/// The semantics are similar to free():
///     - The pointer was previously returned by the allocation function.
///     - The pointer may be NULL, in which case the function shall have no effect.
///     - The execution time should be constant (O(1)).
///
/// The value of the user reference is taken from the corresponding field of the memory resource structure.
typedef void (*UdpardMemoryFree)(void* const user_reference, const size_t size, void* const pointer);

/// A kind of memory resource that can only be used to free memory previously allocated by the user.
/// Instances are mostly intended to be passed by value.
struct UdpardMemoryDeleter
{
    void*            user_reference;  ///< Passed as the first argument.
    UdpardMemoryFree free;            ///< Shall be a valid pointer.
};

/// A memory resource encapsulates the dynamic memory allocation and deallocation facilities.
/// Note that the library allocates a large amount of small fixed-size objects for bookkeeping purposes;
/// allocators for them can be implemented using fixed-size block pools to eliminate extrinsic memory fragmentation.
/// Instances are mostly intended to be passed by value.
struct UdpardMemoryResource
{
    void*                user_reference;  ///< Passed as the first argument.
    UdpardMemoryFree     free;            ///< Shall be a valid pointer.
    UdpardMemoryAllocate allocate;        ///< Shall be a valid pointer.
};

// =====================================================================================================================
// =================================================    TX PIPELINE    =================================================
// =====================================================================================================================

/// The transmission pipeline is a prioritized transmission queue that keeps UDP datagrams (aka transport frames)
/// destined for transmission via one network interface.
/// Applications with redundant network interfaces are expected to have one instance of this type per interface.
/// Applications that are not interested in transmission may have zero such instances.
///
/// All operations are logarithmic in complexity on the number of enqueued items.
/// There is exactly one memory allocation per element;
/// the size of each allocation is sizeof(UdpardTxItem) plus the size of the datagram.
///
/// Once initialized, instances cannot be copied.
///
/// API functions that work with this type are named "udpardTx*()", find them below.
///
/// FUTURE: Eventually we might consider adding another way of arranging the transmission pipeline where the UDP
/// datagrams ready for transmission are not enqueued into the local prioritized queue but instead are sent directly
/// to the network interface driver using a dedicated callback. The callback would accept not just a single
/// chunk of data but a list of three chunks to avoid copying the source transfer payload: the datagram header,
/// the payload, and (only for the last frame) the CRC. The driver would then use some form of vectorized IO to
/// transmit the data; the advantage of this approach is that up to two data copy operations are eliminated from the
/// stack and the memory allocator is not used at all. The disadvantage is that if the driver callback is blocking,
/// the application thread will be blocked as well; plus the driver will be responsible for the correct prioritization
/// of the outgoing datagrams according to the DSCP value.
struct UdpardTx
{
    /// Pointer to the node-ID of the local node, which is used to populate the source node-ID field of outgoing
    /// transfers.
    /// This is made a pointer to allow the user to easily change the node-ID after a plug-and-play node-ID allocation
    /// across multiple instances (remember there is a separate instance per redundant interface).
    /// The node-ID value should be set to UDPARD_NODE_ID_UNSET if the local node is anonymous
    /// (e.g., during PnP allocation or if no transmission is needed).
    const UdpardNodeID* local_node_id;

    /// The maximum number of UDP datagrams this instance is allowed to enqueue.
    /// An attempt to push more will fail with UDPARD_ERROR_CAPACITY.
    /// The purpose of this limitation is to ensure that a blocked queue does not exhaust the memory.
    size_t queue_capacity;

    /// The maximum number of Cyphal transfer payload bytes per UDP datagram.
    /// The Cyphal/UDP header and the final CRC are added to this value to obtain the total UDP datagram payload size.
    /// See UDPARD_MTU_*.
    /// The value can be changed arbitrarily at any time between enqueue operations.
    /// The value is constrained by the library to be positive.
    size_t mtu;

    /// The mapping from the Cyphal priority level in [0,7], where the highest priority is at index 0
    /// and the lowest priority is at the last element of the array, to the IP DSCP field value.
    /// See UdpardPriority.
    /// By default, the mapping is initialized per the recommendations given in the Cyphal/UDP specification.
    /// The value can be changed arbitrarily at any time between enqueue operations.
    uint_least8_t dscp_value_per_priority[UDPARD_PRIORITY_MAX + 1U];

    /// The memory resource used by this queue for allocating the enqueued items (UDP datagrams).
    /// There is exactly one allocation per enqueued item, each allocation contains both the UdpardTxItem
    /// and its payload, hence the size is variable.
    /// In a simple application there would be just one memory resource shared by all parts of the library.
    /// If the application knows its MTU, it can use block allocation to avoid extrinsic fragmentation.
    struct UdpardMemoryResource memory;

    /// The number of frames that are currently contained in the queue, initially zero.
    /// READ-ONLY
    size_t queue_size;

    /// Internal use only.
    /// READ-ONLY
    struct UdpardTreeNode* root;
};

/// One transport frame (UDP datagram) stored in the UdpardTx transmission queue along with its metadata.
/// The datagram should be sent to the indicated UDP/IP endpoint with the specified DSCP value.
/// The datagram should be discarded (transmission aborted) if the deadline has expired.
/// All fields are READ-ONLY.
struct UdpardTxItem
{
    /// Internal use only; do not access this field.
    struct UdpardTreeNode base;

    /// Points to the next frame in this transfer or NULL. This field is mostly intended for own needs of the library.
    /// Normally, the application would not use it because transfer frame ordering is orthogonal to global TX ordering.
    /// It can be useful though for pulling pending frames from the TX queue if at least one frame of their transfer
    /// failed to transmit; the idea is that if at least one frame is missing, the transfer will not be received by
    /// remote nodes anyway, so all its remaining frames can be dropped from the queue at once using udpardTxPop().
    struct UdpardTxItem* next_in_transfer;

    /// This is the same value that is passed to udpardTxPublish/Request/Respond.
    /// Frames whose transmission deadline is in the past should be dropped (transmission aborted).
    UdpardMicrosecond deadline_usec;

    /// The IP differentiated services code point (DSCP) is used to prioritize UDP frames on the network.
    /// LibUDPard selects the DSCP value based on the transfer priority level and the configured DSCP mapping.
    uint_least8_t dscp;

    /// This UDP/IP datagram compiled by libudpard should be sent to this endpoint.
    /// The endpoint is always at a multicast address.
    struct UdpardUDPIPEndpoint destination;

    /// The completed UDP/IP datagram payload. This includes the Cyphal header as well as all required CRCs.
    /// It should be sent through the socket (or equivalent abstraction) verbatim.
    struct UdpardMutablePayload datagram_payload;

    /// This opaque pointer is assigned the value that is passed to udpardTxPublish/Request/Respond.
    /// The library itself does not make use of it but the application can use it to provide continuity between
    /// its high-level transfer objects and datagrams that originate from it.
    /// If not needed, the application can set it to NULL.
    void* user_transfer_reference;
};

/// Construct a new transmission pipeline with the specified queue capacity and memory resource.
/// Refer to the documentation for UdpardTx for more information.
/// The other parameters will be initialized to the recommended defaults automatically,
/// which can be changed later by modifying the struct fields directly.
/// No memory allocation is going to take place until the pipeline is actually written to.
///
/// The instance does not hold any resources itself except for the allocated memory.
/// To safely discard it, simply pop all enqueued frames from it.
///
/// The time complexity is constant. This function does not invoke the dynamic memory manager.
int_fast8_t udpardTxInit(struct UdpardTx* const            self,
                         const UdpardNodeID* const         local_node_id,
                         const size_t                      queue_capacity,
                         const struct UdpardMemoryResource memory);

/// This function serializes a message transfer into a sequence of UDP datagrams and inserts them into the prioritized
/// transmission queue at the appropriate position. Afterwards, the application is supposed to take the enqueued frames
/// from the transmission queue using the function udpardTxPeek and transmit them one by one. Each transmitted
/// (or discarded, e.g., due to timeout) frame should be removed from the queue using udpardTxPop. The enqueued items
/// are prioritized according to their Cyphal transfer priority to avoid the inner priority inversion. The transfer
/// payload will be copied into the transmission queue so that the lifetime of the datagrams is not related to the
/// lifetime of the input payload buffer.
///
/// The MTU of the generated datagrams is dependent on the value of the MTU setting at the time when this function
/// is invoked. The MTU setting can be changed arbitrarily between invocations.
///
/// The pointer to the transfer_id will be used to populate the transfer_id field of the generated datagrams and
/// then to increment the pointed-to value to prepare it for the next publication.
/// There shall be a separate transfer-ID counter per subject (topic).
/// The lifetime of the pointed-to transfer-ID counter must exceed the lifetime of the intent to publish on this
/// subject (topic); one common approach is to use a static variable.
/// The transfer-ID counter is not modified if the function fails.
///
/// The user_transfer_reference is an opaque pointer that will be assigned to the user_transfer_reference field of
/// each enqueued item. The library itself does not use or check this value in any way, so it can be NULL if not needed.
///
/// The deadline_usec value will be used to populate the eponymous field of the generated datagrams
/// (all will share the same deadline value).
/// This feature is intended to allow aborting frames that could not be transmitted before the specified deadline;
/// therefore, normally, the timestamp value should be in the future.
/// The library itself, however, does not use or check this value in any way, so it can be zero if not needed
/// (this is not recommended for real-time systems).
///
/// The function returns the number of UDP datagrams enqueued, which is always a positive number, in case of success.
/// In case of failure, the function returns a negated error code.
///
/// UDPARD_ERROR_ARGUMENT may be returned in the following cases:
///     - Any of the input arguments except user_transfer_reference are NULL.
///     - The priority or the port-ID exceed their respective maximums.
///     - The payload pointer is NULL while the payload size is nonzero.
///
/// UDPARD_ERROR_ANONYMOUS is returned if local node is anonymous (the local node-ID is unset) and
/// the transfer payload cannot fit into a single datagram (a multi-frame transfer is required).
///
/// UDPARD_ERROR_MEMORY is returned if a TX frame could not be allocated due to the memory being exhausted.
/// UDPARD_ERROR_CAPACITY is returned if the capacity of the queue would be exceeded by this operation.
/// In such cases, all frames allocated for this transfer (if any) will be deallocated automatically.
/// In other words, either all frames of the transfer are enqueued successfully, or none are.
///
/// The memory allocation requirement is one allocation per datagram:
/// a single-frame transfer takes one allocation; a multi-frame transfer of N frames takes N allocations.
/// The size of each allocation is (sizeof(UdpardTxItem) + MTU) except for the last datagram where the payload may be
/// smaller than the MTU.
///
/// The time complexity is O(p + log e), where p is the amount of payload in the transfer, and e is the number of
/// frames already enqueued in the transmission queue.
int32_t udpardTxPublish(struct UdpardTx* const     self,
                        const UdpardMicrosecond    deadline_usec,
                        const enum UdpardPriority  priority,
                        const UdpardPortID         subject_id,
                        UdpardTransferID* const    transfer_id,
                        const struct UdpardPayload payload,
                        void* const                user_transfer_reference);

/// This is similar to udpardTxPublish except that it is intended for service request transfers.
/// It takes the node-ID of the server that is intended to receive the request.
///
/// The pointer to the transfer_id will be used to populate the transfer_id field of the generated datagrams and
/// then to increment the pointed-to value to prepare it for the next request.
/// There shall be a separate transfer-ID counter per pair of (service-ID, server node-ID).
/// The lifetime of the pointed-to transfer-ID counter must exceed the lifetime of the intent to invoke this service
/// on this server node; one common approach is to use a static array indexed by the server node-ID per service-ID
/// (memory-constrained applications may choose a more compact container).
///
/// Additional error conditions:
///     - UDPARD_ERROR_ARGUMENT if the server node-ID value is invalid.
///     - UDPARD_ERROR_ANONYMOUS if the local node is anonymous (the local node-ID is unset).
///
/// Other considerations are the same as for udpardTxPublish.
int32_t udpardTxRequest(struct UdpardTx* const     self,
                        const UdpardMicrosecond    deadline_usec,
                        const enum UdpardPriority  priority,
                        const UdpardPortID         service_id,
                        const UdpardNodeID         server_node_id,
                        UdpardTransferID* const    transfer_id,
                        const struct UdpardPayload payload,
                        void* const                user_transfer_reference);

/// This is similar to udpardTxRequest except that it takes the node-ID of the client instead of server,
/// and the transfer-ID is passed by value rather than by pointer.
/// The transfer-ID is passed by value because when responding to an RPC-service request, the server must
/// reuse the transfer-ID value of the request (this is to allow the client to match responses with their requests).
int32_t udpardTxRespond(struct UdpardTx* const     self,
                        const UdpardMicrosecond    deadline_usec,
                        const enum UdpardPriority  priority,
                        const UdpardPortID         service_id,
                        const UdpardNodeID         client_node_id,
                        const UdpardTransferID     transfer_id,
                        const struct UdpardPayload payload,
                        void* const                user_transfer_reference);

/// This function accesses the enqueued UDP datagram scheduled for transmission next. The queue itself is not modified
/// (i.e., the accessed element is not removed). The application should invoke this function to collect the datagrams
/// enqueued by udpardTxPublish/Request/Respond whenever the socket (or equivalent abstraction) becomes writable.
///
/// The timestamp values of the enqueued items are initialized with deadline_usec from udpardTxPublish/Request/Respond.
/// The timestamps are used to specify the transmission deadline. It is up to the application and/or the socket layer
/// to implement the discardment of timed-out datagrams. The library does not check it, so a frame that is
/// already timed out may be returned here.
///
/// If the queue is empty or if the argument is NULL, the returned value is NULL.
///
/// If the queue is non-empty, the returned value is a pointer to its top element (i.e., the next item to transmit).
/// The returned pointer points to an object allocated in the dynamic storage; it should be eventually freed by the
/// application by calling udpardTxFree with UdpardTx::memory. The memory shall not be freed before the item is removed
/// from the queue by calling udpardTxPop; this is because until udpardTxPop is executed, the library retains
/// ownership of the item. The pointer retains validity until explicitly freed by the application; in other words,
/// calling udpardTxPop does not invalidate the object.
///
/// The payload buffer is located shortly after the object itself, in the same memory fragment. The application shall
/// not attempt to free it.
///
/// Calling functions that modify the queue may cause the next invocation to return a different pointer.
///
/// The time complexity is logarithmic of the queue size. This function does not invoke the dynamic memory manager.
const struct UdpardTxItem* udpardTxPeek(const struct UdpardTx* const self);

/// This function transfers the ownership of the specified item of the prioritized transmission queue from the queue
/// to the application. The item does not necessarily need to be the top one -- it is safe to dequeue any item.
/// The item is dequeued but not invalidated; it is the responsibility of the application to deallocate its memory
/// later. The memory SHALL NOT be deallocated UNTIL this function is invoked.
/// The function returns the same pointer that it is given except that it becomes mutable.
///
/// If any of the arguments are NULL, the function has no effect and returns NULL.
///
/// The time complexity is logarithmic of the queue size. This function does not invoke the dynamic memory manager.
struct UdpardTxItem* udpardTxPop(struct UdpardTx* const self, const struct UdpardTxItem* const item);

/// This is a simple helper that frees the memory allocated for the item with the correct size.
/// It is needed because the application does not have access to the required context to compute the size.
/// If the chosen allocator does not leverage the size information, the deallocation function can be invoked directly.
/// If the item argument is NULL, the function has no effect. The time complexity is constant.
void udpardTxFree(const struct UdpardMemoryResource memory, struct UdpardTxItem* const item);

// =====================================================================================================================
// =================================================    RX PIPELINE    =================================================
// =====================================================================================================================

/// This type represents an open input port, such as a subscription to a subject (topic), a service server port
/// that accepts RPC-service requests, or a service client port that accepts RPC-service responses.
///
/// The library performs transfer reassembly, deduplication, and integrity checks, along with the management of
/// redundant network interfaces.
struct UdpardRxPort
{
    /// The maximum payload size that can be accepted at this port.
    /// The rest will be truncated away following the implicit truncation rule defined in the Cyphal specification.
    /// READ-ONLY
    size_t extent;

    /// Refer to the Cyphal specification for the description of the transfer-ID timeout.
    /// By default, this is set to UDPARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC and it can be changed by the user.
    /// This field can be adjusted at runtime arbitrarily; e.g., this is useful to implement adaptive timeouts.
    UdpardMicrosecond transfer_id_timeout_usec;

    /// Libudpard creates a new session instance per remote node-ID that emits transfers matching this port.
    /// For example, if the local node is subscribed to a certain subject and there are X nodes publishing
    /// transfers on that subject, then there will be X sessions created for that subject.
    /// Same applies to RPC-services as well.
    ///
    /// Once a session is created, it is never freed again until the port that owns it (this structure) is destroyed.
    /// This is in line with the assumption that the network configuration is usually mostly static, and that
    /// once a node has started emitting data on a certain port, it is likely to continue doing so.
    /// Applications where this is not the case may consider cycling their ports periodically
    /// by destroying and re-creating them immediately.
    ///
    /// Each session instance takes sizeof(UdpardInternalRxSession) bytes of dynamic memory for itself,
    /// which is at most 512 bytes on wide-word platforms (on small word size platforms it is usually much smaller).
    /// On top of that, each session instance holds memory for the transfer payload fragments and small fixed-size
    /// metadata objects called "fragment handles" (at most 128 bytes large, usually much smaller,
    /// depending on the pointer width and the word size), one handle per fragment.
    ///
    /// The transfer payload memory is not allocated by the library but rather moved from the application
    /// when the corresponding UDP datagram is received. If the library chooses to keep the frame payload
    /// (which is the case if the frame is not a duplicate, the frame sequence is valid, and the received payload
    /// does not exceed the extent configured for the port), a new fragment handle is allocated and it takes ownership
    /// of the entire datagram payload (including all overheads such as the Cyphal/UDP frame header and possible
    /// data that spills over the configured extent value for this port).
    /// If the library does not need the datagram to reassemble the transfer, its payload buffer is freed immediately.
    /// There is a 1-to-1 correspondence between the fragment handles and the payload fragments.
    /// Remote nodes that emit highly fragmented transfers cause a higher memory utilization in the local node
    /// because of the increased number of fragment handles and per-datagram overheads.
    ///
    /// In the worst case, the library may keep up to two full transfer payloads in memory at the same time
    /// (two transfer states are kept to allow acceptance of interleaved frames).
    ///
    /// Ultimately, the worst-case memory consumption is dependent on the configured extent and the transmitting
    /// side's MTU, as these parameters affect the number of payload buffers retained in memory.
    ///
    /// The maximum memory consumption is when there is a large number of nodes emitting data such that each node
    /// begins a multi-frame transfer while never completing it.
    ///
    /// Everything stated above holds for service transfers as well.
    ///
    /// If the dynamic memory pool(s) is(are) sized correctly, and all transmitting nodes are known to avoid excessive
    /// fragmentation of egress transfers (which can be ensured by not using MTU values smaller than the default),
    /// the application is guaranteed to never encounter an out-of-memory (OOM) error at runtime.
    /// High-integrity applications can optionally police ingress traffic for MTU violations and filter it before
    /// passing it to the library; alternatively, applications could limit memory consumption per port,
    /// which is easy to implement since each port gets a dedicated set of memory resources.
    ///
    /// READ-ONLY
    struct UdpardInternalRxSession* sessions;
};

/// The set of memory resources is used per an RX pipeline instance such as subscription or a service dispatcher.
/// These are used to serve the memory needs of the library to keep state while reassembling incoming transfers.
/// Several memory resources are provided to enable fine control over the allocated memory;
/// simple applications may choose to use the same memory resource implemented via malloc()/free() for all of them.
struct UdpardRxMemoryResources
{
    /// The session memory resource is used to provide memory for the session instances described above.
    /// Each instance is fixed-size, so a trivial zero-fragmentation block allocator is sufficient.
    struct UdpardMemoryResource session;

    /// The fragment handles are allocated per payload fragment; each handle contains a pointer to its fragment.
    /// Each instance is of a very small fixed size, so a trivial zero-fragmentation block allocator is sufficient.
    struct UdpardMemoryResource fragment;

    /// The library never allocates payload buffers itself, as they are handed over by the application via
    /// udpardRx*Receive. Once a buffer is handed over, the library may choose to keep it if it is deemed to be
    /// necessary to complete a transfer reassembly, or to discard it if it is deemed to be unnecessary.
    /// Discarded payload buffers are freed using this object.
    struct UdpardMemoryDeleter payload;
};

/// Represents a received Cyphal transfer.
/// The payload is owned by this instance, so the application must free it after use; see udpardRxTransferFree.
struct UdpardRxTransfer
{
    UdpardMicrosecond   timestamp_usec;
    enum UdpardPriority priority;
    UdpardNodeID        source_node_id;
    UdpardTransferID    transfer_id;

    /// The total size of the payload available to the application, in bytes, is provided for convenience;
    /// it is the sum of the sizes of all its fragments. For example, if the sender emitted a transfer of 2000
    /// bytes split into two frames, 1408 bytes in the first frame and 592 bytes in the second frame,
    /// then the payload_size will be 2000 and the payload buffer will contain two fragments of 1408 and 592 bytes.
    /// The transfer CRC is not included here. If the received payload exceeds the configured extent,
    /// the excess payload will be discarded and the payload_size will be set to the extent.
    ///
    /// The application is given ownership of the payload buffer, so it is required to free it after use;
    /// this requires freeing both the handles and the payload buffers they point to.
    /// Beware that different memory resources may have been used to allocate the handles and the payload buffers;
    /// the application is responsible for freeing them using the correct memory resource.
    ///
    /// If the payload is empty, the corresponding buffer pointers may be NULL.
    size_t                payload_size;
    struct UdpardFragment payload;
};

/// This is, essentially, a helper that frees the memory allocated for the payload and its fragment headers
/// using the correct memory resources. The application can do the same thing manually if it has access to the
/// required context to compute the size, or if the memory resource implementation does not require deallocation size.
///
/// The head of the fragment list is passed by value so it is not freed. This is in line with the UdpardRxTransfer
/// design, where the head is stored by value to reduce indirection in small transfers. We call it Scott's Head.
///
/// If any of the arguments are NULL, the function has no effect.
void udpardRxFragmentFree(const struct UdpardFragment       head,
                          struct UdpardMemoryResource const memory_fragment,
                          struct UdpardMemoryDeleter const  memory_payload);

// ---------------------------------------------  SUBJECTS  ---------------------------------------------

/// This is a specialization of a port for subject (topic) subscriptions.
///
/// In Cyphal/UDP, each subject (topic) has a specific IP multicast group address associated with it.
/// This address is contained in the field named "udp_ip_endpoint".
/// The application is expected to open a separate socket bound to that endpoint per redundant interface,
/// and then feed the UDP datagrams received from these sockets into udpardRxSubscriptionReceive,
/// collecting UdpardRxTransfer instances at the output.
///
/// Observe that the subscription pipeline is entirely independent of the node-ID of the local node.
/// This is by design, allowing nodes to listen to subjects without having to be present online.
struct UdpardRxSubscription
{
    /// See UdpardRxPort.
    /// Use this to change the transfer-ID timeout value for this subscription.
    struct UdpardRxPort port;

    /// The IP multicast group address and the UDP port number where UDP/IP datagrams matching this Cyphal
    /// subject will be sent by the publishers (remote nodes).
    /// READ-ONLY
    struct UdpardUDPIPEndpoint udp_ip_endpoint;

    /// Refer to UdpardRxMemoryResources.
    struct UdpardRxMemoryResources memory;
};

/// To subscribe to a subject, the application should do this:
///
///     1. Create a new UdpardRxSubscription instance.
///
///     2. Initialize it by calling udpardRxSubscriptionInit. The subject-ID and port-ID are synonymous here.
///
///     3. Per redundant network interface:
///        - Create a new socket bound to the IP multicast group address and UDP port number specified in the
///          udp_ip_endpoint field of the initialized subscription instance. The library will determine the
///          endpoint to use based on the subject-ID.
///
///     4. Read data from the sockets continuously and forward each received UDP datagram to
///        udpardRxSubscriptionReceive, along with the index of the redundant interface the datagram was received on.
///
/// The extent defines the maximum possible size of received objects, considering also possible future data type
/// versions with new fields. It is safe to pick larger values.
/// Note well that the extent is not the same thing as the maximum size of the object, it is usually larger!
/// Transfers that carry payloads that exceed the specified extent will be accepted anyway but the excess payload
/// will be truncated away, as mandated by the Specification. The transfer CRC is always validated regardless of
/// whether its payload is truncated.
///
/// By default, the transfer-ID timeout value is set to UDPARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC.
/// It can be changed by the user at any time by modifying the corresponding field in the subscription instance.
///
/// The return value is 0 on success.
/// The return value is a negated UDPARD_ERROR_ARGUMENT if any of the input arguments are invalid.
///
/// The time complexity is constant. This function does not invoke the dynamic memory manager.
int_fast8_t udpardRxSubscriptionInit(struct UdpardRxSubscription* const   self,
                                     const UdpardPortID                   subject_id,
                                     const size_t                         extent,
                                     const struct UdpardRxMemoryResources memory);

/// Frees all memory held by the subscription instance.
/// After invoking this function, the instance is no longer usable.
/// Do not forget to close the sockets that were opened for this subscription.
void udpardRxSubscriptionFree(struct UdpardRxSubscription* const self);

/// Datagrams received from the sockets of this subscription are fed into this function.
///
/// The timestamp value indicates the arrival time of the datagram; the arrival time of the earliest datagram of
/// a transfer becomes the transfer timestamp upon successful reassembly.
/// This value is also used for the transfer-ID timeout management.
/// Usually, naive software timestamping is adequate for these purposes, but some applications may require
/// a greater accuracy (e.g., for time synchronization).
///
/// The redundant interface index shall not exceed UDPARD_NETWORK_INTERFACE_COUNT_MAX.
///
/// The function takes ownership of the passed datagram payload buffer. The library will either store it as a
/// fragment of the reassembled transfer payload or free it using the corresponding memory resource
/// (see UdpardRxMemoryResources) if the datagram is not needed for reassembly. Because of the ownership transfer,
/// the datagram payload buffer has to be mutable (non-const).
///
/// The accepted datagram may either be invalid, carry a non-final part of a multi-frame transfer,
/// carry a final part of a valid multi-frame transfer, or carry a valid single-frame transfer.
/// The last two cases are said to complete a transfer.
///
/// If the datagram completes a transfer, the out_transfer argument is filled with the transfer details
/// and the return value is one.
/// The caller is assigned ownership of the transfer payload buffer memory; it has to be freed after use as described
/// in the documentation for UdpardRxTransfer.
/// The memory pointed to by out_transfer may be mutated arbitrarily if no transfer is completed.
///
/// If the datagram does not complete a transfer or is malformed, the function returns zero and the out_transfer
/// is not modified. Observe that malformed frames are not treated as errors, as the local application is not
/// responsible for the behavior of external agents producing the datagrams.
///
/// The function invokes the dynamic memory manager in the following cases only (refer to UdpardRxPort for details):
///
///     1. A new session state instance is allocated when a new session is initiated.
///
///     2. A new transfer fragment handle is allocated when a new transfer fragment is accepted.
///
///     3. Allocated objects may occasionally be deallocated at the discretion of the library.
///        This behavior does not increase the worst case execution time and does not improve the worst case memory
///        consumption, so a deterministic application need not consider this behavior in its resource analysis.
///        This behavior is implemented for the benefit of applications where rigorous characterization is unnecessary.
///
/// The time complexity is O(log n) where n is the number of remote notes publishing on this subject (topic).
/// No data copy takes place. Malformed frames are discarded in constant time.
/// Linear time is spent on the CRC verification of the transfer payload when the transfer is complete.
///
/// This function performs log(n) of recursive calls internally, where n is the number of frames in a transfer.
///
/// UDPARD_ERROR_MEMORY is returned if the function fails to allocate memory.
/// UDPARD_ERROR_ARGUMENT is returned if any of the input arguments are invalid.
int_fast8_t udpardRxSubscriptionReceive(struct UdpardRxSubscription* const self,
                                        const UdpardMicrosecond            timestamp_usec,
                                        const struct UdpardMutablePayload  datagram_payload,
                                        const uint_fast8_t                 redundant_iface_index,
                                        struct UdpardRxTransfer* const     out_transfer);

// ---------------------------------------------  RPC-SERVICES  ---------------------------------------------

/// An RPC-service RX port models the interest of the application in receiving RPC-service transfers of
/// a particular kind (request or response) and a particular service-ID.
struct UdpardRxRPC
{
    /// READ-ONLY
    struct UdpardTreeNode base;

    /// READ-ONLY
    UdpardPortID service_id;

    /// See UdpardRxPort.
    /// Use this to change the transfer-ID timeout value for this RPC-service port.
    struct UdpardRxPort port;

    /// This field can be arbitrarily mutated by the user. It is never accessed by the library.
    /// Its purpose is to simplify integration with OOP interfaces.
    void* user_reference;
};

/// A service dispatcher is a collection of RPC-service RX ports.
///
/// In Cyphal/UDP, each node has a specific IP multicast group address where RPC-service transfers destined to that
/// node are sent to. This is similar to subject (topic) multicast group addressed except that the node-ID takes
/// the place of the subject-ID. The IP multicast group address is derived from the local node-ID.
/// This address is available in the field named "udp_ip_endpoint".
/// The application is expected to open a separate socket bound to that endpoint per redundant interface,
/// and then feed the UDP datagrams received from these sockets into udpardRxRPCDispatcherReceive,
/// collecting UdpardRxRPCTransfer instances at the output.
///
/// Anonymous nodes (nodes without a node-ID of their own) cannot use RPC-services.
struct UdpardRxRPCDispatcher
{
    /// The IP address and UDP port number where UDP/IP datagrams carrying RPC-service transfers destined to this node
    /// will be sent.
    /// READ-ONLY
    struct UdpardUDPIPEndpoint udp_ip_endpoint;

    /// Refer to UdpardRxMemoryResources.
    struct UdpardRxMemoryResources memory;

    /// READ-ONLY
    struct UdpardRxRPC* request_ports;
    struct UdpardRxRPC* response_ports;
};

/// Represents a received Cyphal RPC-service transfer -- either request or response.
struct UdpardRxRPCTransfer
{
    struct UdpardRxTransfer base;
    UdpardPortID            service_id;
    bool                    is_request;
};

/// To begin receiving RPC-service requests and/or responses, the application should do this:
///
///     1. Create a new UdpardRxRPCDispatcher instance.
///
///     2. Initialize it by calling udpardRxRPCDispatcherInit. Observe that a valid node-ID is required here.
///        If the application has to perform a plug-and-play node-ID allocation, it has to complete that beforehand.
///        The dispatcher is not needed to perform PnP node-ID allocation.
///
///     3. Per redundant network interface:
///        - Create a new socket bound to the IP multicast group address and UDP port number specified in the
///          udp_ip_endpoint field of the initialized service dispatcher instance. The library will determine the
///          endpoint to use based on the node-ID.
///
///     4. Announce its interest in specific RPC-services (requests and/or responses) by calling
///        udpardRxRPCDispatcherListen per each. This can be done at any later point as well.
///
///     5. Read data from the sockets continuously and forward each received UDP datagram to
///        udpardRxRPCDispatcherReceive, along with the index of the redundant interface
///        the datagram was received on. Only those services that were announced in step 4 will be processed.
///
/// The return value is 0 on success.
/// The return value is a negated UDPARD_ERROR_ARGUMENT if any of the input arguments are invalid.
///
/// The time complexity is constant. This function does not invoke the dynamic memory manager.
int_fast8_t udpardRxRPCDispatcherInit(struct UdpardRxRPCDispatcher* const  self,
                                      const UdpardNodeID                   local_node_id,
                                      const struct UdpardRxMemoryResources memory);

/// Frees all memory held by the RPC-service dispatcher instance.
/// After invoking this function, the instance is no longer usable.
/// Do not forget to close the sockets that were opened for this instance.
void udpardRxRPCDispatcherFree(struct UdpardRxRPCDispatcher* const self);

/// This function lets the application register its interest in a particular service-ID and kind (request/response)
/// by creating an RPC-service RX port. The service pointer shall retain validity until its unregistration or until
/// the dispatcher is destroyed. The service instance shall not be moved or destroyed.
///
/// If such registration already exists, it will be unregistered first as if udpardRxRPCDispatcherCancel was
/// invoked by the application, and then re-created anew with the new parameters.
///
/// For the meaning of extent, please refer to the documentation of the subscription pipeline.
///
/// By default, the transfer-ID timeout value is set to UDPARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC.
/// It can be changed by the user at any time by modifying the corresponding field in the registration instance.
///
/// The return value is 1 if a new registration has been created as requested.
/// The return value is 0 if such registration existed at the time the function was invoked. In this case,
/// the existing registration is terminated and then a new one is created in its place. Pending transfers may be lost.
/// The return value is a negated UDPARD_ERROR_ARGUMENT if any of the input arguments are invalid.
///
/// The time complexity is logarithmic from the number of current registrations under the specified transfer kind
/// (request or response).
/// This function does not allocate new memory. The function may deallocate memory if such registration already
/// existed; the deallocation behavior is specified in the documentation for udpardRxRPCDispatcherCancel.
int_fast8_t udpardRxRPCDispatcherListen(struct UdpardRxRPCDispatcher* const self,
                                        struct UdpardRxRPC* const           service,
                                        const UdpardPortID                  service_id,
                                        const bool                          is_request,
                                        const size_t                        extent);

/// This function reverses the effect of udpardRxRPCDispatcherListen.
/// If the registration is found, all its memory is de-allocated (session states and payload buffers).
/// Please refer to the UdpardRxPort session description for detailed information on the amount of memory freed.
///
/// The return value is 1 if such registration existed (and, therefore, it was removed).
/// The return value is 0 if such registration does not exist. In this case, the function has no effect.
/// The return value is a negated UDPARD_ERROR_ARGUMENT if any of the input arguments are invalid.
///
/// The time complexity is logarithmic from the number of current registration under the specified transfer kind.
/// This function does not allocate new memory.
int_fast8_t udpardRxRPCDispatcherCancel(struct UdpardRxRPCDispatcher* const self,
                                        const UdpardPortID                  service_id,
                                        const bool                          is_request);

/// Datagrams received from the sockets of this service dispatcher are fed into this function.
/// It is the analog of udpardRxSubscriptionReceive for RPC-service transfers.
/// Please refer to the documentation of udpardRxSubscriptionReceive for the usage information.
int_fast8_t udpardRxRPCDispatcherReceive(struct UdpardRxRPCDispatcher* const self,
                                         struct UdpardRxRPC** const          service,
                                         const UdpardMicrosecond             timestamp_usec,
                                         const struct UdpardMutablePayload   datagram_payload,
                                         const uint_fast8_t                  redundant_iface_index,
                                         struct UdpardRxRPCTransfer* const   out_transfer);

#ifdef __cplusplus
}
#endif
#endif
